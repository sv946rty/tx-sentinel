import { z } from "zod"

/**
 * User question input schema.
 * Validated on form submission via Server Action.
 */
export const questionInputSchema = z.object({
  question: z
    .string()
    .min(1, "Question is required")
    .max(2000, "Question must be less than 2000 characters")
    .trim(),
})

export type QuestionInput = z.infer<typeof questionInputSchema>

/**
 * Agent plan schema.
 * Represents the explicit, structured plan generated by the agent.
 */
export const agentPlanSchema = z.object({
  objective: z.string().describe("What the agent is trying to accomplish"),
  steps: z
    .array(
      z.object({
        step: z.number(),
        action: z.string().describe("What the agent will do"),
        reasoning: z.string().describe("Why this step is necessary"),
      })
    )
    .min(1, "Plan must have at least one step"),
  requiresMemory: z
    .boolean()
    .describe("Whether prior memory may be relevant to this question"),
})

export type AgentPlan = z.infer<typeof agentPlanSchema>

/**
 * Memory existence check schema.
 * Represents whether a similar question has been asked before.
 * This is SEPARATE from whether memory is needed for reasoning.
 */
export const memoryExistenceCheckSchema = z.object({
  similarQuestionExists: z.boolean().describe("Whether a similar question was asked before"),
  existingRunId: z.string().uuid().optional().describe("ID of the similar question, if found"),
  existingQuestion: z.string().optional().describe("The similar question text, if found"),
  existingAnswer: z.string().optional().describe("The previous answer, if found"),
  searchQuery: z.string().describe("Query used to search for similar questions"),
  explanation: z.string().describe("Explanation of the similarity check result"),
})

export type MemoryExistenceCheck = z.infer<typeof memoryExistenceCheckSchema>

/**
 * Memory dependency decision schema.
 * Represents whether prior memory is REQUIRED to answer the current question correctly.
 * This is SEPARATE from whether similar questions exist.
 */
export const memoryDependencyDecisionSchema = z.object({
  requiresMemory: z.boolean().describe("Whether prior memory is needed to answer correctly"),
  reason: z.string().describe("Why memory is or is not required for reasoning"),
  contextNeeded: z.array(z.string()).optional().describe("Specific prior context needed, if any"),
  pronounResolution: z.object({
    hasPronouns: z.boolean().describe("Whether the question contains pronouns or implicit references"),
    pronounsFound: z.array(z.string()).optional().describe("List of pronouns/references found"),
    resolutionAttempted: z.boolean().describe("Whether resolution was attempted"),
    resolved: z.boolean().optional().describe("Whether pronouns were successfully resolved"),
    resolvedEntities: z.array(z.object({
      pronoun: z.string(),
      resolvedTo: z.string(),
      confidence: z.number().min(0).max(1),
    })).optional().describe("Resolved entities with confidence scores"),
    resolutionExplanation: z.string().optional().describe("Explanation of how resolution was done"),
  }).optional().describe("Pronoun and implicit reference resolution details"),
})

export type MemoryDependencyDecision = z.infer<typeof memoryDependencyDecisionSchema>

/**
 * Combined memory decision schema.
 * Contains both existence check and dependency decision.
 */
export const memoryDecisionSchema = z.object({
  existenceCheck: memoryExistenceCheckSchema,
  dependencyDecision: memoryDependencyDecisionSchema,
  shouldRetrieveMemory: z.boolean().describe("Final decision: whether to retrieve additional memory beyond existence check"),
  searchQuery: z
    .string()
    .optional()
    .describe("Additional search query for retrieving broader context, if needed"),
})

export type MemoryDecision = z.infer<typeof memoryDecisionSchema>

/**
 * Reasoning step schema.
 * Represents a single step in the agent's reasoning loop.
 * These are user-facing, high-level descriptions â€” NOT raw chain-of-thought.
 */
export const reasoningStepSchema = z.object({
  step: z.number(),
  type: z.enum([
    "planning",
    "memory_existence_check",
    "memory_dependency_decision",
    "pronoun_resolution",
    "memory_retrieval",
    "reasoning",
    "generating_answer",
  ]),
  description: z
    .string()
    .describe("User-facing description of what the agent is doing"),
  timestamp: z.string().datetime(),
})

export type ReasoningStep = z.infer<typeof reasoningStepSchema>

/**
 * Tool usage record schema.
 * Tracks which tools were used during the agent run.
 */
export const toolUsageSchema = z.object({
  toolName: z.enum(["memory_retrieval", "result_persistence", "decision"]),
  invokedAt: z.string().datetime(),
  success: z.boolean(),
})

export type ToolUsage = z.infer<typeof toolUsageSchema>

/**
 * Retrieved memory schema.
 * Represents a prior question/answer that was retrieved from memory.
 */
export const retrievedMemorySchema = z.object({
  runId: z.string().uuid(),
  question: z.string(),
  answer: z.string(),
  createdAt: z.string().datetime(),
  relevanceScore: z.number().min(0).max(1).optional(),
})

export type RetrievedMemory = z.infer<typeof retrievedMemorySchema>

/**
 * Agent run result schema.
 * The complete output of an agent run, stored in the database.
 */
export const agentRunResultSchema = z.object({
  id: z.string().uuid(),
  userId: z.string(),
  question: z.string(),
  plan: agentPlanSchema,
  memoryDecision: memoryDecisionSchema,
  retrievedMemories: z.array(retrievedMemorySchema),
  reasoningSteps: z.array(reasoningStepSchema),
  toolsUsed: z.array(toolUsageSchema),
  answer: z.string(),
  createdAt: z.string().datetime(),
})

export type AgentRunResult = z.infer<typeof agentRunResultSchema>

/**
 * Streaming event schemas.
 * Events sent to the client during agent execution.
 */
export const streamEventSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("reasoning_step"),
    data: reasoningStepSchema,
  }),
  z.object({
    type: z.literal("answer_chunk"),
    data: z.object({
      chunk: z.string(),
    }),
  }),
  z.object({
    type: z.literal("complete"),
    data: z.object({
      runId: z.string().uuid(),
    }),
  }),
  z.object({
    type: z.literal("error"),
    data: z.object({
      message: z.string(),
    }),
  }),
])

export type StreamEvent = z.infer<typeof streamEventSchema>
